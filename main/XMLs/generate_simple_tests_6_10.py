#!/usr/bin/env python3
"""
Simple but effective generator for Tests 6-10.
Extracts answers in order from .txt files and creates summary_completion questions.
"""

import re, os, sys
from datetime import datetime
from html import escape

def serialize_php(data):
    if data is None:
        return 'N;'
    elif isinstance(data, bool):
        return 'b:1;' if data else 'b:0;'
    elif isinstance(data, int):
        return f'i:{data};'
    elif isinstance(data, float):
        return f'd:{data};'
    elif isinstance(data, str):
        byte_length = len(data.encode('utf-8'))
        return f's:{byte_length}:"{data}";'
    elif isinstance(data, dict):
        items = []
        for key, value in data.items():
            items.append(serialize_php(key) + serialize_php(value))
        items_str = ''.join(items)
        return f'a:{len(data)}:{{{items_str}}}'
    elif isinstance(data, list):
        items = []
        for i, value in enumerate(data):
            items.append(serialize_php(i) + serialize_php(value))
        items_str = ''.join(items)
        return f'a:{len(data)}:{{{items_str}}}'
    else:
        return 'N;'

def parse_answer(answer_text):
    """Parse {[ans1][ans2]|ans3} format"""
    answer_text = answer_text.strip('{}')
    variants = re.findall(r'\[([^\]]+)\]', answer_text)
    if variants:
        return '|'.join(v.lower() for v in variants)
    else:
        return answer_text.lower()

def extract_audio(content):
    match = re.search(r'\[audio mp3="([^"]+)"\]', content)
    return match.group(1) if match else ""

def extract_transcript(content):
    match = re.search(r'<div[^>]*style="[^"]*overflow:\s*scroll[^"]*"[^>]*>(.*?)</div>', content, re.DOTALL | re.IGNORECASE)
    if match:
        return match.group(1).strip()
    match = re.search(r'(<table[^>]*>.*?</table>)', content, re.DOTALL | re.IGNORECASE)
    if match:
        return match.group(1)
    return ""

def generate_xml(test_num, section_num, questions, audio_url, transcript):
    """Generate complete XML."""
    now = datetime.now()
    
    questions_serialized = serialize_php(questions)
    starting_q_num = (section_num - 1) * 10 + 1
    
    xml_content = f'''<?xml version="1.0" encoding="UTF-8"?>
<!--
 Generated by generate_simple_tests_6_10.py on {now.strftime("%Y-%m-%d %H:%M:%S")} 
-->
<rss xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:wp="http://wordpress.org/export/1.2/" version="2.0">
<channel>
<title>IELTStestONLINE</title>
<link>https://www.ieltstestonline.com/2026</link>
<description>Online IELTS preparation</description>
<pubDate>{now.strftime("%a, %d %b %Y %H:%M:%S +0000")}</pubDate>
<language>en-NZ</language>
<wp:wxr_version>1.2</wp:wxr_version>
<wp:base_site_url>https://www.ieltstestonline.com/2026</wp:base_site_url>
<wp:base_blog_url>https://www.ieltstestonline.com/2026</wp:base_blog_url>
<wp:author>
<wp:author_id>1</wp:author_id>
<wp:author_login><![CDATA[impact]]></wp:author_login>
<wp:author_email><![CDATA[impact@ieltstestonline.com]]></wp:author_email>
<wp:author_display_name><![CDATA[impact]]></wp:author_display_name>
<wp:author_first_name><![CDATA[Patrick]]></wp:author_first_name>
<wp:author_last_name><![CDATA[Bourne]]></wp:author_last_name>
</wp:author>
<generator>IELTS Course Manager - generate_simple_tests_6_10.py</generator>
<item>
<title><![CDATA[Listening Test {test_num} Section {section_num}]]></title>
<link>https://www.ieltstestonline.com/2026/ielts-quiz/listening-test-{test_num}-section-{section_num}/</link>
<pubDate>{now.strftime("%a, %d %b %Y %H:%M:%S +0000")}</pubDate>
<dc:creator><![CDATA[impact]]></dc:creator>
<guid isPermaLink="false">https://www.ieltstestonline.com/2026/?post_type=ielts_quiz&amp;p=AUTO</guid>
<description/>
<content:encoded><![CDATA[]]></content:encoded>
<excerpt:encoded><![CDATA[]]></excerpt:encoded>
<wp:post_id>AUTO</wp:post_id>
<wp:post_date><![CDATA[{now.strftime("%Y-%m-%d %H:%M:%S")}]]></wp:post_date>
<wp:post_date_gmt><![CDATA[{now.strftime("%Y-%m-%d %H:%M:%S")}]]></wp:post_date_gmt>
<wp:post_modified><![CDATA[{now.strftime("%Y-%m-%d %H:%M:%S")}]]></wp:post_modified>
<wp:post_modified_gmt><![CDATA[{now.strftime("%Y-%m-%d %H:%M:%S")}]]></wp:post_modified_gmt>
<wp:comment_status><![CDATA[closed]]></wp:comment_status>
<wp:ping_status><![CDATA[closed]]></wp:ping_status>
<wp:post_name><![CDATA[listening-test-{test_num}-section-{section_num}]]></wp:post_name>
<wp:status><![CDATA[publish]]></wp:status>
<wp:post_parent>0</wp:post_parent>
<wp:menu_order>0</wp:menu_order>
<wp:post_type><![CDATA[ielts_quiz]]></wp:post_type>
<wp:post_password><![CDATA[]]></wp:post_password>
<wp:is_sticky>0</wp:is_sticky>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_questions]]></wp:meta_key>
<wp:meta_value><![CDATA[{questions_serialized}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_reading_texts]]></wp:meta_key>
<wp:meta_value><![CDATA[a:0:{{}}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_pass_percentage]]></wp:meta_key>
<wp:meta_value><![CDATA[70]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_layout_type]]></wp:meta_key>
<wp:meta_value><![CDATA[listening_practice]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_exercise_label]]></wp:meta_key>
<wp:meta_value><![CDATA[practice_test]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_open_as_popup]]></wp:meta_key>
<wp:meta_value><![CDATA[]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_scoring_type]]></wp:meta_key>
<wp:meta_value><![CDATA[ielts_listening]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_timer_minutes]]></wp:meta_key>
<wp:meta_value><![CDATA[]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_starting_question_number]]></wp:meta_key>
<wp:meta_value><![CDATA[{starting_q_num}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_audio_url]]></wp:meta_key>
<wp:meta_value><![CDATA[{audio_url}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_transcript]]></wp:meta_key>
<wp:meta_value><![CDATA[{transcript}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_audio_sections]]></wp:meta_key>
<wp:meta_value><![CDATA[a:0:{{}}]]></wp:meta_value>
</wp:postmeta>
</item>
</channel>
</rss>
'''
    
    return xml_content

def extract_question_context(content, answer_index):
    """Extract the question text/context for a given answer."""
    # Find all answer blocks with their positions
    pattern = r'\{[^}]+\}'
    matches = list(re.finditer(pattern, content))
    
    if answer_index >= len(matches):
        return f"Question {answer_index + 1}"
    
    match = matches[answer_index]
    answer_start = match.start()
    answer_end = match.end()
    
    # First, check if the question is on the same line (before the answer)
    # Look backwards from answer to find the start of the line
    line_start = content.rfind('\n', 0, answer_start) + 1
    same_line_text = content[line_start:answer_start].strip()
    
    # Clean up same-line text
    same_line_text = re.sub(r'</?li>', '', same_line_text)  # Remove <li> tags
    same_line_text = re.sub(r'^\d+\.\s*', '', same_line_text)  # Remove number prefix
    same_line_text = re.sub(r'<[^>]+>', '', same_line_text)  # Remove other HTML tags
    same_line_text = same_line_text.strip()
    
    # If we found meaningful text on the same line (e.g., a question), use it
    if same_line_text and len(same_line_text) > 5 and '?' in same_line_text:
        return same_line_text
    
    # For standalone answers (like "5. {E}"), look for surrounding context
    # Get the entire chunk from previous answer to current answer
    start_pos = 0
    if answer_index > 0:
        start_pos = matches[answer_index - 1].end()
    
    question_chunk = content[start_pos:answer_start]
    
    # Try to find a summary/paragraph with numbered placeholders
    # Look for pattern like "text 7. {answer} more text 8. {answer}"
    # This indicates a fill-in-the-blank paragraph
    
    # Check if this looks like part of a summary paragraph
    # by seeing if there are sentence fragments around the answer
    before_answer = content[max(0, answer_start - 200):answer_start]
    after_answer = content[answer_end:min(len(content), answer_end + 200)]
    
    # If surrounded by sentence text (lowercase letters before and after), it's likely a summary
    if (re.search(r'[a-z]\s*\d*\.?\s*$', before_answer) and 
        re.search(r'^\s*\.?\s*[A-Z]?[a-z]', after_answer)):
        # Extract the full summary paragraph
        # Find the start of the paragraph (look for instruction text or blank line)
        para_start = question_chunk.rfind('\n\n')
        if para_start == -1:
            para_start = question_chunk.rfind('below')
            if para_start != -1:
                para_start = question_chunk.find('\n', para_start)
        
        if para_start != -1:
            full_para = question_chunk[para_start:].strip()
            # Clean and extract the summary text
            full_para = re.sub(r'<[^>]+>', '', full_para)  # Remove HTML
            full_para = re.sub(r'\s+', ' ', full_para).strip()  # Normalize whitespace
            
            # Find the sentence containing this answer
            sentences = re.split(r'[.!?]\s+', full_para)
            for sent in sentences:
                if str(answer_index + 1) in sent or re.search(r'\d+\s*$', sent):
                    # Found the sentence with this question number
                    clean_sent = re.sub(r'\d+\s*$', '', sent).strip()
                    if clean_sent:
                        return clean_sent + '.'
    
    # Check if this is a standalone answer (just number and answer on a line)
    # If so, look for shared instructions in the broader context
    standalone_pattern = r'^\d+\.\s*$'
    if re.match(standalone_pattern, same_line_text) or not same_line_text:
        # Look further back for instructions (e.g., "Label the map...")
        # Go back up to 500 characters or 2 previous answers
        lookback_start = 0
        if answer_index >= 2:
            lookback_start = matches[answer_index - 2].end()
        elif answer_index >= 1:
            lookback_start = matches[answer_index - 1].end()
        
        lookback_chunk = content[lookback_start:answer_start]
        
        # Look for instruction lines
        lines = lookback_chunk.split('\n')
        for line in reversed(lines):
            line = line.strip()
            # Look for instruction-like text (not numbers, not HTML only, not empty)
            if (line and 
                not re.match(r'^\d+\.?\s*$', line) and
                not re.match(r'^<[^>]+>$', line) and
                len(line) > 10 and
                ('below' in line.lower() or 'following' in line.lower() or 
                 'label' in line.lower() or 'choose' in line.lower() or
                 'write' in line.lower() or 'complete' in line.lower())):
                # Clean the instruction
                clean_instr = re.sub(r'<[^>]+>', '', line)
                return clean_instr.strip()
    
    # Otherwise, look for context in the surrounding text
    lines = question_chunk.split('\n')
    cleaned_lines = []
    
    for line in lines:
        line = line.strip()
        # Skip empty lines, separators, and pure HTML tags
        if not line or line in ['<hr />', '<hr/>', '<hr>', '&nbsp;']:
            continue
        if line.startswith('Questions ') or (line.startswith('Question ') and '-' in line):
            continue  # Skip question range headers like "Questions 1-10"
        if line.startswith('<') and line.endswith('>') and line.count('<') <= 2:
            continue  # Skip pure HTML tags
        
        # Remove HTML tags but keep content
        line = re.sub(r'</?li>', '', line)
        line = re.sub(r'</?ol[^>]*>', '', line)
        line = re.sub(r'</?em>', '', line)
        line = re.sub(r'<hr\s*/>', '', line)
        line = re.sub(r'<img[^>]*>', '', line)  # Remove images
        line = re.sub(r'^\d+\.\s*$', '', line)  # Remove standalone numbers
        
        line = line.strip()
        if line and len(line) > 3 and not line.startswith('style='):
            cleaned_lines.append(line)
    
    # Take the last meaningful line as the question
    if cleaned_lines:
        # Filter out overly long lines that might be instructions
        # and prefer lines with question-like content
        for line in reversed(cleaned_lines):
            # Remove strong/em tags for comparison
            clean_line = re.sub(r'<[^>]+>', '', line)
            if len(clean_line) < 200 and len(clean_line) > 5:  # Reasonable question length
                return line
    
    return f"Question {answer_index + 1}"

def generate_section(test_num, section_num):
    """Generate one section."""
    txt_file = f"Listening Test {test_num} Section {section_num}.txt"
    
    if not os.path.exists(txt_file):
        print(f"  ✗ {txt_file} not found")
        return False
    
    with open(txt_file, 'r') as f:
        content = f.read()
    
    audio_url = extract_audio(content)
    transcript = extract_transcript(content)
    
    # Extract all {answer} blocks
    answer_blocks = re.findall(r'\{([^}]+)\}', content)
    
    if len(answer_blocks) < 10:
        print(f"  ⚠️  Only found {len(answer_blocks)} answers")
        return False
    
    # Create 10 summary_completion questions
    questions = []
    for i in range(10):
        answer = parse_answer('{' + answer_blocks[i] + '}')
        display_answer = answer.split('|')[0].upper()
        
        # Extract question context
        question_text = extract_question_context(content, i)
        if not question_text:
            question_text = f'Question {i+1}'
        
        questions.append({
            'type': 'summary_completion',
            'instructions': '',
            'question': question_text,
            'points': 1.0,
            'summary_fields': {
                1: {
                    'answer': answer,
                    'correct_feedback': 'Correct!',
                    'incorrect_feedback': 'Incorrect.',
                    'no_answer_feedback': f'The correct answer is: {display_answer}. Make sure to listen carefully for key information and take notes while listening.'
                }
            },
            'options': '',
            'correct_answer': '',
            'no_answer_feedback': 'In the IELTS test, you should always take a guess. You don\'t lose points for a wrong answer.',
            'correct_feedback': 'Correct!',
            'incorrect_feedback': 'Incorrect.',
            'reading_text_id': None
        })
    
    xml_content = generate_xml(test_num, section_num, questions, audio_url, transcript)
    
    xml_file = f"Listening Test {test_num} Section {section_num}.xml"
    with open(xml_file, 'w', encoding='utf-8') as f:
        f.write(xml_content)
    
    print(f"  ✓ Generated {xml_file} with {len(questions)} questions")
    return True

def main():
    os.chdir("/home/runner/work/ielts-preparation-course/ielts-preparation-course/main/XMLs")
    
    print("=" * 80)
    print("GENERATING TESTS 6-10 (Simple Answer Extraction)")
    print("=" * 80)
    
    for test_num in [6, 7, 8, 9, 10]:
        print(f"\nTest {test_num}:")
        for section_num in [1, 2, 3, 4]:
            generate_section(test_num, section_num)
    
    print("\n" + "=" * 80)
    print("DONE!")
    print("=" * 80)

if __name__ == "__main__":
    main()
