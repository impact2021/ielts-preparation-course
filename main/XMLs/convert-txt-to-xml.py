#!/usr/bin/env python3
"""
Convert listening test TXT files to XML and generate annotated transcripts.

Usage:
    python convert-txt-to-xml.py "Listening Test 1 Section 1.txt"
    
This will generate:
    - Listening Test 1 Section 1.xml
    - Listening Test 1 Section 1-transcript.txt
"""

import re
import sys
import os
from datetime import datetime
from html import escape
import xml.etree.ElementTree as ET

def extract_questions_from_txt(txt_content):
    """Extract questions and answers from TXT file."""
    questions = []
    
    # Find all {ANSWER} patterns with question numbers
    # Strategy: Look for any occurrence of number followed by answer in braces
    # Handles formats like: "31 text {ANSWER}" and "32. text {ANSWER}"
    
    # Pattern matches: word boundary + number (1-50) NOT followed by dash (to avoid ranges like "31-35")
    # optionally followed by period/space, then text (max 200 chars), then {answer}
    pattern = r'\b(\d{1,2})(?![-–])[\.:\s]+[^{}]{0,200}?{([^}]+)}'
    
    for match in re.finditer(pattern, txt_content):
        q_num = int(match.group(1))
        
        # Only accept question numbers 1-50 (typical for IELTS)
        if q_num < 1 or q_num > 50:
            continue
            
        answer_text = match.group(2).strip()
        
        # Skip if we already have this question
        if any(q['number'] == q_num for q in questions):
            continue
        
        # Handle multiple answers separated by brackets
        # e.g., {[2 YEARS][TWO YEARS]} becomes "2 years|two years"
        answer_variants = re.findall(r'\[([^\]]+)\]', answer_text)
        if answer_variants:
            answer = '|'.join(v.lower() for v in answer_variants)
        else:
            answer = answer_text.lower()
        
        questions.append({
            'number': q_num,
            'answer': answer
        })
    
    # Sort by question number
    questions.sort(key=lambda q: q['number'])
    
    return questions

def extract_transcript_from_txt(txt_content):
    """Extract the transcript table from TXT file."""
    # Find the transcript table - try multiple patterns
    # Pattern 1: table with class="style1"
    table_pattern = r'(<table[^>]*class="style1"[^>]*>.*?</table>)'
    match = re.search(table_pattern, txt_content, re.DOTALL | re.IGNORECASE)
    
    if match:
        return match.group(1)
    
    # Pattern 2: div with overflow scroll (contains the transcript text)
    div_pattern = r'<div[^>]*overflow:\s*scroll[^>]*>(.*?)</div>'
    match = re.search(div_pattern, txt_content, re.DOTALL | re.IGNORECASE)
    
    if match:
        # Extract just the text content, wrap in a simple structure
        transcript_content = match.group(1).strip()
        return f'<div class="transcript">{transcript_content}</div>'
    
    return ""

def annotate_transcript(transcript, questions):
    """Annotate transcript with answer markers like [Q1: answer]."""
    if not transcript or not questions:
        return transcript
    
    annotated = transcript
    
    for q in questions:
        q_num = q['number']
        answer_text = q['answer']
        
        # Split by | to get all variants
        variants = answer_text.split('|')
        
        # Try each variant
        for variant in variants:
            variant = variant.strip()
            if not variant:
                continue
            
            # Check if already annotated
            if f'[Q{q_num}:' in annotated:
                break
            
            # Build regex pattern with word boundaries
            # Allow flexible spacing
            pattern_text = re.escape(variant)
            pattern_text = pattern_text.replace(r'\ ', r'\s+')
            pattern = r'\b(' + pattern_text + r')\b'
            
            # Try to find and annotate (case-insensitive)
            # Note: Yellow highlighting added per user request for easy visibility
            def replace_func(m):
                return f'<strong style="background-color: yellow;">[Q{q_num}: {escape(m.group(1))}]</strong>'
            
            new_annotated = re.sub(pattern, replace_func, annotated, count=1, flags=re.IGNORECASE)
            
            if new_annotated != annotated:
                annotated = new_annotated
                break
    
    return annotated

def generate_xml(title, questions, transcript, audio_url=""):
    """Generate XML content."""
    # This is a simplified XML generator
    # In a real implementation, you would parse the full question structure
    # For now, we'll create a basic structure
    
    xml_template = f'''<?xml version="1.0" encoding="UTF-8"?>
<!--
 This is a WordPress eXtended RSS file for IELTS Course Manager exercise export 
-->
<!--
 Generated by convert-txt-to-xml.py on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")} 
-->
<rss xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:wp="http://wordpress.org/export/1.2/" version="2.0">
<channel>
<title>IELTStestONLINE</title>
<link>https://www.ieltstestonline.com/2026</link>
<description>Online IELTS preparation</description>
<pubDate>{datetime.now().strftime("%a, %d %b %Y %H:%M:%S +0000")}</pubDate>
<language>en-NZ</language>
<wp:wxr_version>1.2</wp:wxr_version>
<wp:base_site_url>https://www.ieltstestonline.com/2026</wp:base_site_url>
<wp:base_blog_url>https://www.ieltstestonline.com/2026</wp:base_blog_url>
<wp:author>
<wp:author_id>1</wp:author_id>
<wp:author_login><![CDATA[impact]]></wp:author_login>
<wp:author_email><![CDATA[impact@ieltstestonline.com]]></wp:author_email>
<wp:author_display_name><![CDATA[impact]]></wp:author_display_name>
<wp:author_first_name><![CDATA[Patrick]]></wp:author_first_name>
<wp:author_last_name><![CDATA[Bourne]]></wp:author_last_name>
</wp:author>
<generator>IELTS Course Manager - convert-txt-to-xml.py</generator>
<item>
<title><![CDATA[{escape(title)}]]></title>
<link>https://www.ieltstestonline.com/2026/ielts-quiz/{title.lower().replace(" ", "-")}/</link>
<pubDate>{datetime.now().strftime("%a, %d %b %Y %H:%M:%S +0000")}</pubDate>
<dc:creator><![CDATA[impact]]></dc:creator>
<guid isPermaLink="false">https://www.ieltstestonline.com/2026/?post_type=ielts_quiz&amp;p=AUTO</guid>
<description/>
<content:encoded><![CDATA[]]></content:encoded>
<excerpt:encoded><![CDATA[]]></excerpt:encoded>
<wp:post_id>AUTO</wp:post_id>
<wp:post_date><![CDATA[{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}]]></wp:post_date>
<wp:post_date_gmt><![CDATA[{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}]]></wp:post_date_gmt>
<wp:post_modified><![CDATA[{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}]]></wp:post_modified>
<wp:post_modified_gmt><![CDATA[{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}]]></wp:post_modified_gmt>
<wp:comment_status><![CDATA[closed]]></wp:comment_status>
<wp:ping_status><![CDATA[closed]]></wp:ping_status>
<wp:post_name><![CDATA[{title.lower().replace(" ", "-")}]]></wp:post_name>
<wp:status><![CDATA[publish]]></wp:status>
<wp:post_parent>0</wp:post_parent>
<wp:menu_order>0</wp:menu_order>
<wp:post_type><![CDATA[ielts_quiz]]></wp:post_type>
<wp:post_password><![CDATA[]]></wp:post_password>
<wp:is_sticky>0</wp:is_sticky>
<!-- Questions will be added by WordPress import tool -->
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_questions]]></wp:meta_key>
<wp:meta_value><![CDATA[a:0:{{}}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_reading_texts]]></wp:meta_key>
<wp:meta_value><![CDATA[a:0:{{}}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_pass_percentage]]></wp:meta_key>
<wp:meta_value><![CDATA[70]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_layout_type]]></wp:meta_key>
<wp:meta_value><![CDATA[listening_practice]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_exercise_label]]></wp:meta_key>
<wp:meta_value><![CDATA[practice_test]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_open_as_popup]]></wp:meta_key>
<wp:meta_value><![CDATA[]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_scoring_type]]></wp:meta_key>
<wp:meta_value><![CDATA[ielts_listening]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_timer_minutes]]></wp:meta_key>
<wp:meta_value><![CDATA[]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_starting_question_number]]></wp:meta_key>
<wp:meta_value><![CDATA[1]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_audio_url]]></wp:meta_key>
<wp:meta_value><![CDATA[{audio_url}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_transcript]]></wp:meta_key>
<wp:meta_value><![CDATA[{transcript}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_audio_sections]]></wp:meta_key>
<wp:meta_value><![CDATA[a:0:{{}}]]></wp:meta_value>
</wp:postmeta>
</item>
</channel>
</rss>
'''
    
    return xml_template

def main():
    if len(sys.argv) < 2:
        print("Usage: python convert-txt-to-xml.py <input.txt>")
        print("Example: python convert-txt-to-xml.py 'Listening Test 1 Section 1.txt'")
        sys.exit(1)
    
    input_file = sys.argv[1]
    
    if not os.path.exists(input_file):
        print(f"Error: File '{input_file}' not found")
        sys.exit(1)
    
    # Read input file
    with open(input_file, 'r', encoding='utf-8') as f:
        txt_content = f.read()
    
    # Extract title from filename
    base_name = os.path.splitext(os.path.basename(input_file))[0]
    title = base_name
    
    # Extract audio URL
    audio_match = re.search(r'\[audio mp3="([^"]+)"\]', txt_content)
    audio_url = audio_match.group(1) if audio_match else ""
    
    # Extract questions
    questions = extract_questions_from_txt(txt_content)
    print(f"Extracted {len(questions)} questions")
    
    # Extract transcript
    transcript = extract_transcript_from_txt(txt_content)
    print(f"Extracted transcript ({len(transcript)} chars)")
    
    # Annotate transcript
    annotated_transcript = annotate_transcript(transcript, questions)
    print(f"Annotated transcript with answer markers")
    
    # Generate XML
    xml_content = generate_xml(title, questions, annotated_transcript, audio_url)
    
    # Save XML file
    xml_output = base_name + ".xml"
    with open(xml_output, 'w', encoding='utf-8') as f:
        f.write(xml_content)
    print(f"✓ Generated {xml_output}")
    
    # Save annotated transcript file
    transcript_output = base_name + "-transcript.txt"
    with open(transcript_output, 'w', encoding='utf-8') as f:
        f.write(annotated_transcript)
    print(f"✓ Generated {transcript_output}")
    
    print("\nDone!")

if __name__ == "__main__":
    main()
