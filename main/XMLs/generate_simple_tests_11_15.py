#!/usr/bin/env python3
"""
Simple but effective generator for Tests 11-15.
Extracts answers in order from .txt files and creates summary_completion questions.
"""

import re, os, sys
from datetime import datetime
from html import escape

def serialize_php(data):
    if data is None:
        return 'N;'
    elif isinstance(data, bool):
        return 'b:1;' if data else 'b:0;'
    elif isinstance(data, int):
        return f'i:{data};'
    elif isinstance(data, float):
        return f'd:{data};'
    elif isinstance(data, str):
        byte_length = len(data.encode('utf-8'))
        return f's:{byte_length}:"{data}";'
    elif isinstance(data, dict):
        items = []
        for key, value in data.items():
            items.append(serialize_php(key) + serialize_php(value))
        items_str = ''.join(items)
        return f'a:{len(data)}:{{{items_str}}}'
    elif isinstance(data, list):
        items = []
        for i, value in enumerate(data):
            items.append(serialize_php(i) + serialize_php(value))
        items_str = ''.join(items)
        return f'a:{len(data)}:{{{items_str}}}'
    else:
        return 'N;'

def parse_answer(answer_text):
    """Parse {[ans1][ans2]|ans3} format"""
    answer_text = answer_text.strip('{}')
    variants = re.findall(r'\[([^\]]+)\]', answer_text)
    if variants:
        return '|'.join(v.lower() for v in variants)
    else:
        return answer_text.lower()

def extract_audio(content):
    match = re.search(r'\[audio mp3="([^"]+)"\]', content)
    return match.group(1) if match else ""

def extract_transcript(content):
    match = re.search(r'<div[^>]*style="[^"]*overflow:\s*scroll[^"]*"[^>]*>(.*?)</div>', content, re.DOTALL | re.IGNORECASE)
    if match:
        return match.group(1).strip()
    match = re.search(r'(<table[^>]*>.*?</table>)', content, re.DOTALL | re.IGNORECASE)
    if match:
        return match.group(1)
    return ""

def generate_xml(test_num, section_num, questions, audio_url, transcript):
    """Generate complete XML."""
    now = datetime.now()
    
    questions_serialized = serialize_php(questions)
    starting_q_num = (section_num - 1) * 10 + 1
    
    xml_content = f'''<?xml version="1.0" encoding="UTF-8"?>
<!--
 Generated by generate_simple_tests_11_15.py on {now.strftime("%Y-%m-%d %H:%M:%S")} 
-->
<rss xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:wp="http://wordpress.org/export/1.2/" version="2.0">
<channel>
<title>IELTStestONLINE</title>
<link>https://www.ieltstestonline.com/2026</link>
<description>Online IELTS preparation</description>
<pubDate>{now.strftime("%a, %d %b %Y %H:%M:%S +0000")}</pubDate>
<language>en-NZ</language>
<wp:wxr_version>1.2</wp:wxr_version>
<wp:base_site_url>https://www.ieltstestonline.com/2026</wp:base_site_url>
<wp:base_blog_url>https://www.ieltstestonline.com/2026</wp:base_blog_url>
<wp:author>
<wp:author_id>1</wp:author_id>
<wp:author_login><![CDATA[impact]]></wp:author_login>
<wp:author_email><![CDATA[impact@ieltstestonline.com]]></wp:author_email>
<wp:author_display_name><![CDATA[impact]]></wp:author_display_name>
<wp:author_first_name><![CDATA[Patrick]]></wp:author_first_name>
<wp:author_last_name><![CDATA[Bourne]]></wp:author_last_name>
</wp:author>
<generator>IELTS Course Manager - generate_simple_tests_11_15.py</generator>
<item>
<title><![CDATA[Listening Test {test_num} Section {section_num}]]></title>
<link>https://www.ieltstestonline.com/2026/ielts-quiz/listening-test-{test_num}-section-{section_num}/</link>
<pubDate>{now.strftime("%a, %d %b %Y %H:%M:%S +0000")}</pubDate>
<dc:creator><![CDATA[impact]]></dc:creator>
<guid isPermaLink="false">https://www.ieltstestonline.com/2026/?post_type=ielts_quiz&amp;p=AUTO</guid>
<description/>
<content:encoded><![CDATA[]]></content:encoded>
<excerpt:encoded><![CDATA[]]></excerpt:encoded>
<wp:post_id>AUTO</wp:post_id>
<wp:post_date><![CDATA[{now.strftime("%Y-%m-%d %H:%M:%S")}]]></wp:post_date>
<wp:post_date_gmt><![CDATA[{now.strftime("%Y-%m-%d %H:%M:%S")}]]></wp:post_date_gmt>
<wp:post_modified><![CDATA[{now.strftime("%Y-%m-%d %H:%M:%S")}]]></wp:post_modified>
<wp:post_modified_gmt><![CDATA[{now.strftime("%Y-%m-%d %H:%M:%S")}]]></wp:post_modified_gmt>
<wp:comment_status><![CDATA[closed]]></wp:comment_status>
<wp:ping_status><![CDATA[closed]]></wp:ping_status>
<wp:post_name><![CDATA[listening-test-{test_num}-section-{section_num}]]></wp:post_name>
<wp:status><![CDATA[publish]]></wp:status>
<wp:post_parent>0</wp:post_parent>
<wp:menu_order>0</wp:menu_order>
<wp:post_type><![CDATA[ielts_quiz]]></wp:post_type>
<wp:post_password><![CDATA[]]></wp:post_password>
<wp:is_sticky>0</wp:is_sticky>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_questions]]></wp:meta_key>
<wp:meta_value><![CDATA[{questions_serialized}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_reading_texts]]></wp:meta_key>
<wp:meta_value><![CDATA[a:0:{{}}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_pass_percentage]]></wp:meta_key>
<wp:meta_value><![CDATA[70]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_layout_type]]></wp:meta_key>
<wp:meta_value><![CDATA[listening_practice]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_exercise_label]]></wp:meta_key>
<wp:meta_value><![CDATA[practice_test]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_open_as_popup]]></wp:meta_key>
<wp:meta_value><![CDATA[]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_scoring_type]]></wp:meta_key>
<wp:meta_value><![CDATA[ielts_listening]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_timer_minutes]]></wp:meta_key>
<wp:meta_value><![CDATA[]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_starting_question_number]]></wp:meta_key>
<wp:meta_value><![CDATA[{starting_q_num}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_audio_url]]></wp:meta_key>
<wp:meta_value><![CDATA[{audio_url}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_transcript]]></wp:meta_key>
<wp:meta_value><![CDATA[{transcript}]]></wp:meta_value>
</wp:postmeta>
<wp:postmeta>
<wp:meta_key><![CDATA[_ielts_cm_audio_sections]]></wp:meta_key>
<wp:meta_value><![CDATA[a:0:{{}}]]></wp:meta_value>
</wp:postmeta>
</item>
</channel>
</rss>
'''
    
    return xml_content

def generate_section(test_num, section_num):
    """Generate one section."""
    txt_file = f"Listening Test {test_num} Section {section_num}.txt"
    
    if not os.path.exists(txt_file):
        print(f"  ✗ {txt_file} not found")
        return False
    
    with open(txt_file, 'r') as f:
        content = f.read()
    
    audio_url = extract_audio(content)
    transcript = extract_transcript(content)
    
    # Extract all {answer} blocks
    answer_blocks = re.findall(r'\{([^}]+)\}', content)
    
    if len(answer_blocks) < 10:
        print(f"  ⚠️  Only found {len(answer_blocks)} answers")
        return False
    
    # Create 10 summary_completion questions
    questions = []
    for i in range(10):
        answer = parse_answer('{' + answer_blocks[i] + '}')
        display_answer = answer.split('|')[0].upper()
        
        questions.append({
            'type': 'summary_completion',
            'instructions': '',
            'question': f'Question {i+1}',
            'points': 1.0,
            'summary_fields': {
                1: {
                    'answer': answer,
                    'correct_feedback': f'✓ Excellent! "{display_answer}" is correct. You listened carefully and identified the key information.',
                    'incorrect_feedback': f'✗ Not quite. The correct answer is "{display_answer}". Listen to the audio again and check the transcript. Pay attention to keywords and phrases that directly relate to the question. Try to identify signal words that indicate important information is coming.',
                    'no_answer_feedback': f'No answer provided. The correct answer is "{display_answer}". In the IELTS Listening test, you should always attempt every question - there\'s no penalty for wrong answers. Listen to the audio and review the transcript to understand where this information appears and how it\'s presented.'
                }
            },
            'options': '',
            'correct_answer': '',
            'no_answer_feedback': f'No answer provided. The correct answer is "{display_answer}". In the IELTS Listening test, you should always attempt every question - there\'s no penalty for wrong answers. Listen to the audio and review the transcript to understand where this information appears and how it\'s presented.',
            'correct_feedback': f'✓ Excellent! "{display_answer}" is correct. You listened carefully and identified the key information.',
            'incorrect_feedback': f'✗ Not quite. The correct answer is "{display_answer}". Listen to the audio again and check the transcript. Pay attention to keywords and phrases that directly relate to the question. Try to identify signal words that indicate important information is coming.',
            'reading_text_id': None
        })
    
    xml_content = generate_xml(test_num, section_num, questions, audio_url, transcript)
    
    xml_file = f"Listening Test {test_num} Section {section_num}.xml"
    with open(xml_file, 'w', encoding='utf-8') as f:
        f.write(xml_content)
    
    print(f"  ✓ Generated {xml_file} with {len(questions)} questions")
    return True

def main():
    os.chdir("/home/runner/work/ielts-preparation-course/ielts-preparation-course/main/XMLs")
    
    print("=" * 80)
    print("GENERATING TESTS 11-15 (Simple Answer Extraction)")
    print("=" * 80)
    
    for test_num in [11, 12, 13, 14, 15]:
        print(f"\nTest {test_num}:")
        for section_num in [1, 2, 3, 4]:
            generate_section(test_num, section_num)
    
    print("\n" + "=" * 80)
    print("DONE!")
    print("=" * 80)

if __name__ == "__main__":
    main()
